<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>BST、AVL、并查集、堆、哈夫曼</title>
      <link href="/%E7%AE%97%E6%B3%95/BST%E3%80%81AVL%E3%80%81%E5%B9%B6%E6%9F%A5%E9%9B%86%E3%80%81%E5%A0%86%E3%80%81%E5%93%88%E5%A4%AB%E6%9B%BC/"/>
      <url>/%E7%AE%97%E6%B3%95/BST%E3%80%81AVL%E3%80%81%E5%B9%B6%E6%9F%A5%E9%9B%86%E3%80%81%E5%A0%86%E3%80%81%E5%93%88%E5%A4%AB%E6%9B%BC/</url>
      
        <content type="html"><![CDATA[<h2 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h2><p>左结点数据域小于根，右结点数据域大于根</p><pre class=" language-lang-c"><code class="language-lang-c">struct node{    int data;    node *left, *right;};//查找数据域为x的结点void search(node* root, int x){    if (!root)  return;     if (root->data == x)        printf("%d", root->data);    else if (x < root->data)        search(root->left, x);    else        search(root->right, x);}//建立新结点node* newNode(int x){    node* root = new node;    root->data = x;    root->left = root->right = NULL;    return root;}//插入值为x的结点(注意root要加&)void insert(node* &root, int x){    if (!root) {        root = newNode(x);        return;    }    if (x == root->data)        return;    else if (x < root->data)        insert(root->left, x);    else        insert(root->right, x)}//BST的建立node* creat(int data[], int n){    node* root = NULL;    for (int i = 0; i < n; i++)        insert(root, data[i]);  //将data插入到树中    return root;}//寻找以root为根结点的树中的最大权值的结点node* findMax(node* root){    while (root->right)        root = root->right; //不断往右，直到没有右孩子    return root;}//寻找以root为根结点的树中的最小权值的结点node* findMin(node* root){    while (root->left)        root = root->left;  //不断往左，直到没有左孩子    return root;}//删除权值为x的结点void deleteNode(node* &root, int x){    if (!root)  return;    if (root->data == x) {  //找到欲删除结点        if (!root->left && !root->right) {  //叶结点直接删除            root = NULL;    //直接把地址设为空        } else if (!root->left) {   //左子树不为空时            node* pre = findMax(root->left);    //找root的前趋            root->data = pre->data; //用前趋覆盖root            deleteNode(root->left, pre->data);  //在左子树中删除结点pre        } else {    //右子树不为空时            node* next = findMin(root->right);  //找root的后继            root->data = next->data;    //用后继覆盖root            deleteNode(root->right, next->data);//在右子树中删除结点next        }    } else if(root->data > x)        deleteNode(root->left, x);    else        deleteNode(root->right, x);}</code></pre><h3 id="BST的应用"><a href="#BST的应用" class="headerlink" title="BST的应用"></a>BST的应用</h3><p>给出n个整数来作为一棵二叉排序树的结点插入顺序，问：这串序列是否是该二叉树的先序序列或其镜像树的先序序列<br>如果是，则输出YES，并输出对应的树的后序序列；否则，输出NO<br>输入样例:<br>7<br>8 6 5 7 10 8 11<br>输出样例:<br>Yes<br>5 7 6 8 11 10 8</p><pre class=" language-lang-c"><code class="language-lang-c">#include<bits/stdc++.h>using namespace std;struct node{    int data;    node *left, *right;};void insert(node* &root, int data){    if (!root) {        root = new node;        root->data = data;        root->left = root->right = NULL;        return;    }    if (data < root->data)        insert(root->left, data);    else        insert(root->right, data);}//先序遍历void preOrder(node* root, vector<int> &vi){    if (!root)  return;    vi.push_back(root->data);    preOrder(root->left, vi);    preOrder(root->right, vi);}//镜像树的先序遍历void preMirror(node* root, vector<int> &vi){    if (!root)  return;    vi.push_back(root->data);    preMirror(root->right, vi);    preMirror(root->left, vi);}//后序遍历void postOrder(node* root, vector<int> &vi){    if (!root) return;    postOrder(root->left, vi);    postOrder(root->right, vi);    vi.push_back(root->data);}//镜像树的后序遍历void postMirror(node* root, vector<int> &vi){    if (!root) return;    postOrder(root->right, vi);    postOrder(root->left, vi);    vi.push_back(root->data);}//origin存放初始序列//pre、preM为先序，post、postM为后序vector<int> origin, pre, preM, post, postM;int main(){    int n, data;    node* root = NULL;    scanf("%d", &n);    for (int i = 0; i < n; i++) {        scanf("%d", &data);        origin.push_back(data);        insert(root, data);    }    preOrder(root, pre);    preMirror(root, preM);    postOrder(root, post);    postMirror(root, postM);    if (origin == pre) {        printf("YES\n");        for(int i = 0; i < pre.size(); i++) {            printf("%d ", post[i]);        }    } else if (origin == preM) {        printf("YES\n");        for(int i = 0; i < preM.size(); i++) {            printf("%d ", postM[i]);        }    } else        printf("NO\n");}</code></pre><h2 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h2><h3 id="AVL定义"><a href="#AVL定义" class="headerlink" title="AVL定义"></a>AVL定义</h3><p>对于任意结点，其左子树、右子树的高度之差的绝对值不超过1</p><pre class=" language-lang-c"><code class="language-lang-c">struct node{    int v, height;    node *lchild, *rchild;};//生成新结点 node* newNode(int v){    node* root = new node;    root->v = v;    root->height = 1; //初始高度为1    root->lchild = root->rchild = NULL;    return root;}//获取以root为根结点的子树的当前heightint getHeight(node* root){    return root ? root->height : 0;}//计算结点root的平衡因子int getBalanceFactor(node* root){    return getHeight(root->lchild) - getHeight(root->rchild);}//更新root的heightvoid updateHeight(node* root){    root->height = 1 + max(getHeight(root->lchild), getHeight(root->rchild));}</code></pre><h3 id="AVL基本操作"><a href="#AVL基本操作" class="headerlink" title="AVL基本操作"></a>AVL基本操作</h3><p>AVL树插入情况(BF表示平衡因子)</p><div class="table-container"><table><thead><tr><th style="text-align:center">树型</th><th style="text-align:center">判定条件</th><th style="text-align:center">调整方法  </th></tr></thead><tbody><tr><td style="text-align:center">LL</td><td style="text-align:center">BF(root)=2, BF(root-&gt;lchild)=1</td><td style="text-align:center">对root进行右旋</td></tr><tr><td style="text-align:center">LR</td><td style="text-align:center">BF(root)=2, BF(root-&gt;lchild)=-1</td><td style="text-align:center">先对root-&gt;lchild进行左旋，再对root进行右旋</td></tr><tr><td style="text-align:center">RR</td><td style="text-align:center">BF(root)=-2, BF(root-&gt;rchild)=-1</td><td style="text-align:center">对root进行左旋</td></tr><tr><td style="text-align:center">RL</td><td style="text-align:center">BF(root)=-2, BF(root-&gt;rchild)=1</td><td style="text-align:center">先对root-&gt;rchild进行右旋，再对root进行左旋</td></tr></tbody></table></div><pre class=" language-lang-c"><code class="language-lang-c">//左旋void L(node* &root){    node* temp = root->rchild;    root->rchild = temp->lchild;    temp->lchild = root;    updateHeight(root);    updateHeight(temp);    root = temp;}//右旋void R(node* &root){    node* temp = root->lchild;    root->lchild = temp->rchild;    temp->rchild = root;    updateHeight(root);    updateHeight(temp);    root = temp;}//插入结点void insert(node* &root, int v){    if (!root) {        root = newNode(v);        return;    }    if (v < root->v) {  //v比根结点的权值小        insert(root->lchild, v);//往左子树插入        updateHeight(root);//更新树高        if (getBalanceFactor(root) == 2) {            if (getBalanceFactor(root->lchild) == 1)    //LL型                R(root);            else if (getBalanceFactor(root->lchild) == -1) { //LR型                L(root->lchild);                R(root);            }        }    } else {        insert(root->rchild, v);        updateHeight(root);        if (getBalanceFactor(root) == -2) {            if (getBalanceFactor(root->rchild) == -1) { //RR型                L(root);            } else if (getBalanceFactor(root->lchild) == 1) { //RL型                R(root->rchild);                L(root);            }        }    }}</code></pre><h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><pre class=" language-lang-c"><code class="language-lang-c">const int maxn = 100;int father[maxn];//返回x所在集合的根结点int findFather(int x){    return x == father[x] ? x : findFather(father[x]);}//合并结点void merge(int a, int b){    int fa = findFather(a);    int fb = findFather(b);    if (fa != fb)        father[fa] = fb;}//路径压缩，将当前查询结点的路径上的所有结点的父结点都指向根结点//循环写法int findFather1(int x){    //由于x会变成根结点，故先保存    int a = x;      while(x != father[x]) {//寻找根结点        x = father[x];    }    //将路径上所有结点的father改为x    while(a != father[a]) {        int z = a;        a  = father[a];//a回溯父结点        father[z] = x;    }    return x;}//递归写法int findFather2(int x){    if (x == father[x]) return;    int f = findFather(father[x]);    father[x] = f;    return f;}</code></pre><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>堆是一棵完全二叉树。若父结点的值大于或等于孩子结点的值，那么即为大顶堆；若父结点的值小于或等于孩子结点的值，则为小顶堆</p><pre class=" language-lang-c"><code class="language-lang-c">const int maxn = 100;//heap为堆，n为元素个数int heap[maxn], n = 10;//对heap数组在[low，high]的范围进行向下调整//其中low为欲调整结点的数组下标，high一般为堆的最后一个结点的数组下标void downAdjust(int low, int high){    int i = low, j = i * 2;//i为欲调整结点，j为其左孩子    while(j <= high) {//存在孩子结点        if(j + 1 <= high && heap[j + 1] > heap[j])            j = j + 1;//右孩子大则存储右孩子下标        //如果孩子中最大的权值比欲调整的结点i大        if (heap[j] > heap[i]) {            swap(heap[i], heap[j]);//交换            i = j;//保持i为欲调整结点，j为孩子结点            j = i * 2;        } else            break;    }}//建堆void createHeap(){    for (int i = n / 2; i >= 1; i--)        downAdjust(i, n);}//删除堆顶元素void deleteTop(){    heap[1] = heap[n--];//最后一个元素覆盖堆顶元素    downAdjust(1, n);}//对heap数组在[low，high]的范围进行向上调整//其中low一般设置为1，high表示欲调整结点的数组下标void upAdjust(int low, int high){    int i = high, j = i / 2;//i为欲调整结点，j为其父结点    while (j >= low) {        //父结点权值小于i        if (heap[j] < heap[i]) {            swap(heap[j], heap[i]);            i = j;//保持i为欲调整结点，j为i的父结点            j = i / 2;        } else            break;//父结点权值比欲调整结点大，结束    }}//添加元素xvoid insert(int x){    heap[++n] = x;//元素个数加1，数组末尾赋值    upAdjust(1, n);}//堆排序(递增)void heapSort(){    createHeap();//建堆    for (int i = n; i > 1; i--) {//倒着枚举，直到堆中只有一个元素        swap(heap[1], heap[i]);//交换i和堆顶        downAdjust(1, i - 1);//调整堆顶    }}</code></pre><h2 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h2><p>求最小带权路径</p><pre class=" language-lang-c"><code class="language-lang-c">typedef long long ll;//代表小顶堆的优先队列priority_queue<ll, vector<ll> , greater<ll> > q;int main(){    int n;    ll temp, x, y, ans = 0;    scanf("%d", &n);    for (int i = 0; i < n; i++) {        scanf("%lld", &temp);        q.push(temp);    }    while(q.size() > 1) {        x = q.top(); q.pop();        y = q.top(); q.pop();        q.push(x + y);        ans += x + y;    }    printf("%lld\n", ans);    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> c++ </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STL常用容器和函数</title>
      <link href="/%E7%AE%97%E6%B3%95/STL/"/>
      <url>/%E7%AE%97%E6%B3%95/STL/</url>
      
        <content type="html"><![CDATA[<h1 id="STL常用容器和函数"><a href="#STL常用容器和函数" class="headerlink" title="STL常用容器和函数"></a>STL常用容器和函数</h1><h2 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h2><h3 id="元素访问"><a href="#元素访问" class="headerlink" title="元素访问"></a>元素访问</h3><p>1、下标</p><p>2、迭代器</p><pre class=" language-lang-c"><code class="language-lang-c">vector<int> v; for (vector<int>::iterator it = v.begin(); it != v.end(); it++)    printf("% d", *it);</code></pre><h3 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h3><p>push_back(x):尾部添加元素</p><p>pop_back():删除vector的尾元素</p><p>size():元素个数</p><p>clear():清空所有元素</p><p>insert(it, x):向任意迭代器it处插入一个元素x<br><code>v.insert(v.begin() + 2, -1);   //将-1插入v[2]的位置</code></p><p>erase():删除单个元素、删除一个区间内的所有元素</p><pre class=" language-lang-c"><code class="language-lang-c">//erase(it): 删除迭代器为it处的元素//v = [5 6 7 8 9],删除8v.erase(v.begin() + 3); //v.begin()对应v[0]，所以8不是对应v.begin() + 4//erase(first, end):删除[first, last)内的所有元素erase(v.begin() + 1, v.begin() + 4); //删除v[1],v[2],v[3]</code></pre><h3 id="常见用途"><a href="#常见用途" class="headerlink" title="常见用途"></a>常见用途</h3><p>(1) 存储数据<br>(2) 用邻接表存储图</p><h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><p>内部自动有序且不含重复元素的容器<br>set内的元素自动递增排序且自动去除了重复元素</p><h3 id="元素访问-1"><a href="#元素访问-1" class="headerlink" title="元素访问"></a>元素访问</h3><p>只能通过迭代器<br>除开vector和string之外的容器都不支持*(it + i)的访问方式，只能枚举</p><pre class=" language-lang-c"><code class="language-lang-c">set<itn> st;for(set<int>::iterator it = st.begin(); it != st.end(); it++)    printf("%d ", *it)</code></pre><h3 id="常用函数-1"><a href="#常用函数-1" class="headerlink" title="常用函数"></a>常用函数</h3><p>insert(x):插入容器</p><p>find(value):返回set中对应值为value的迭代器<br>‘printf(“%d”, *(st.find(2)); //输出2’</p><p>erase():删除单个元素、删除一个区间内的所有元素</p><pre class=" language-lang-c"><code class="language-lang-c">//erase(it/value)it为所需要删除元素的迭代器，结合find()来使用; value为元素值//st = [100 200 300],删除100st.erase(st.find(100)); st.erase(100);//erase(first, end):删除[first, last)内的所有元素set<int>::iterator it = st.find(30);st.erase(it, st.end()); //删除元素30至set末尾之间的元素</code></pre><p>size():获得元素个数</p><p>clear():清空set</p><h3 id="常见用途-1"><a href="#常见用途-1" class="headerlink" title="常见用途"></a>常见用途</h3><p>最主要作用就是自动去重并按元素升序排序</p><p>注：set中元素唯一，若需要处理不唯一的情况，则需要使用multiset。另外，c++ 11标准中还增加了unordered_set以散列代替set内部的红黑树，使其可以用来处理只去重不排序的需求，速度比set要快得多</p><h2 id="string"><a href="#string" class="headerlink" title="string"></a>string</h2><h3 id="内容访问"><a href="#内容访问" class="headerlink" title="内容访问"></a>内容访问</h3><p>(1)下标访问<br>一般来说，可以直接像字符数组那么去访问string</p><p>若要读入输出整个字符串，则只能用cin、cout</p><p>也可用c_str()将string转换为字符数组输出<br><code>printf(&quot;%s&quot;, str.c_str())</code></p><p>(2)迭代器访问</p><pre class=" language-lang-c"><code class="language-lang-c">string str = "abcd";for (string::iterator it = str.begin(); it != str.end(); it++)    printf("%c", *it);//输出结果a b c d</code></pre><p>string和vector一样，支持直接对迭代器加减数字，如str.begin() + 3</p><h3 id="常用函数-2"><a href="#常用函数-2" class="headerlink" title="常用函数"></a>常用函数</h3><p>length()/size():返回长度</p><p>insert()</p><pre class=" language-lang-c"><code class="language-lang-c">//insert(pos, string), 在pos号位置插入字符串stringstring str = "abcxyz". str2 = "opq";str.insert(3, str2); //输出abcopqxyz//insert(it, it2, it3), it为原字符串的欲插入位置//it2和it3为待插字符串的首尾迭代器，用来表示串[it2,it3)将被插在it的位置上string str = "abcxyz". str2 = "opq";str.insert(str.begin() + 3, str2.begin(), str2.end());//输出abcopqxyz</code></pre><p>erase()</p><pre class=" language-lang-c"><code class="language-lang-c">string str = "abcdefg;//erase(it), 删除单个元素str.erase(str.begin() + 4); //删除e//erase(first, last), 删除区间内元素, 即删除[first, last)str.erase(str.begin() + 2, str.end() - 1);  //删除cdef//erase(pos, length), pos为开始删除起始位置，length为删除的字符个数str.erase(3, 2);    //删除de</code></pre><p>clear():清空string的内容</p><p>substr(pos, len):返回从pos开始，长度为len的字符串</p><p>string::npos<br>是个常数，值为-1，但由于是unsigned_int类型，因此实际上也可认为是unsigned_int类型的最大值(即可认为是-1 或 4294967295)。string::npos用以作为find函数失配时的返回值。</p><p>find():<br>find(str2):当str2是str的字串时，返回其在str中第一次出现的位置；如果不是字串，返回string::npos<br>find(str2, pos):从str的pos位置开始匹配str2，返回值同上</p><p>replace():<br>replace(pos, len, str2):把str从pos位置开始、长度为len的字串替换为str2<br>replace(it1, it2, str2):把str的迭代器[it1, it2)范围的字串替换为str2</p><h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><h3 id="元素访问-2"><a href="#元素访问-2" class="headerlink" title="元素访问"></a>元素访问</h3><pre class=" language-lang-c"><code class="language-lang-c">map<char, int> mp;mp['m'] = 20; mp['m'] = 10;   //覆盖//下标访问printf("%d ", mp['m']);//迭代器访问for (map<char, int>::iterator it = mp.begin(); it != mp.end(); it++)    printf("%c %d", it->first, it->second);</code></pre><p>map会以键从小到大的顺序自动排序，这是由于map内部使用红黑树实现（set也是）在建立映射的过程中会自动实现排序</p><h3 id="常用函数-3"><a href="#常用函数-3" class="headerlink" title="常用函数"></a>常用函数</h3><p>find(key):返回键为key的迭代器<br><code>printf(&quot;%d&quot;, mp.find(&#39;a&#39;)-&gt;second);</code></p><p>erase()</p><pre class=" language-lang-c"><code class="language-lang-c">//erase(it),it为需要删除元素的迭代器mp.erase(mp.find('a'));//erase(key),key为欲删除的映射的键mp.erase('a');//erase(first, last), 删除区间[first, last)mp.erase(mp.find('a'), mp.end());</code></pre><p>size():映射对数 </p><p>clear(): 清空map</p><h3 id="常见用途-2"><a href="#常见用途-2" class="headerlink" title="常见用途"></a>常见用途</h3><p>1、建立映射关系<br>2、判断大整数或其他类型数据是否存在，可把map当bool数组使用</p><p>map的键和值是唯一的，如果需要一个键对应多个值，就只能用multimap。c++ 11标准中还增加了unordered_map，以散列代替map内部的红黑树实现，使其可以只映射而不按key值排序，速度要快得多</p><h2 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h2><h3 id="元素访问-3"><a href="#元素访问-3" class="headerlink" title="元素访问"></a>元素访问</h3><p>由于队列本身的限制，所以只能用front()来访问队首元素，back()来访问队尾元素</p><h3 id="常用函数-4"><a href="#常用函数-4" class="headerlink" title="常用函数"></a>常用函数</h3><p>front(),back(): 访问队首、队尾元素</p><p>pop(): 队首元素出队列</p><p>empty(): 队列是否为空，空则返回true</p><p>size(): 元素个数</p><h3 id="常见用途-3"><a href="#常见用途-3" class="headerlink" title="常见用途"></a>常见用途</h3><p>广度优先搜索<br>STL中的队列还有双端队列(deque)和优先队列(priority_queue),前者首尾皆可插入和删除，后者使用堆实现默认将当前队列最大元素置于队首</p><h2 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a>priority_queue</h2><h3 id="元素访问-4"><a href="#元素访问-4" class="headerlink" title="元素访问"></a>元素访问</h3><p>优先队列没有front和back，而只能通过top()来访问队首元素，也就是优先级最高的元素</p><h3 id="常用函数-5"><a href="#常用函数-5" class="headerlink" title="常用函数"></a>常用函数</h3><p>push(x): x入队</p><p>top(): 获得队首元素</p><p>pop(): 队首元素出队</p><p>empty(): 队列空则返回true</p><p>size(): 元素个数</p><h3 id="优先级设置"><a href="#优先级设置" class="headerlink" title="优先级设置"></a>优先级设置</h3><p>1、基本数据结构的优先级设置(int、char、double等)<br>vector<int> 用来承载底层数据结构堆的容器，如果第一个参数为double或char，则此处只需填写vector<double>或vector<char><br>第三个参数less<int>则是对第一个参数的比较类，less<int>表示数字大的优先级越大，greater<int>表示数字小的优先级越大</int></int></int></char></double></int></p><pre class=" language-lang-c"><code class="language-lang-c">priority_queue<int> q;priority_queue<int, vector<int>, less<int> > q;</code></pre><p>2、结构体的优先级设置，重载小于号 &lt;</p><pre class=" language-lang-c"><code class="language-lang-c">struct fruit {    int price;    friend bool operator < (fruit f1, fruit f2) {        return f1.price < f2.price; //价格高的优先级高    //  return f1.price > f2.price; 价格低的优先级高    }};priority_queue<fruit> q;</code></pre><p>可以发现优先级队列的这个函数与sort中的cmp的效果是相反的,在cmp中’return f1.price &gt; f2.price;’那么价格按从高到低排列</p><p>优先级设置函数也可写在结构体外</p><pre class=" language-lang-c"><code class="language-lang-c">struct cmp {    bool operator () (fruit f1, fruit f2) {        return f1.price > f2.price;     }};priority_queue<fruit, vector<fruit>, cmp> q;</code></pre><p>若结构体内的数据较为庞大(例如出现了字符串或数组),建议使用引用来提高效率，此时比较类的参数中需要加上”const”和”&amp;”</p><pre class=" language-lang-c"><code class="language-lang-c">friend bool operator < (const fruit &f1, const fruit &f2) {    return f1.price < f2.price;  }bool operator () (const fruit &f1, const fruit &f2) {    return f1.price > f2.price; }</code></pre><h3 id="常见用途-4"><a href="#常见用途-4" class="headerlink" title="常见用途"></a>常见用途</h3><p>可解决一些贪心问题，也可对Dijkstra算法进行优化(因为优先队列的本质是堆)</p><h2 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h2><h3 id="元素访问-5"><a href="#元素访问-5" class="headerlink" title="元素访问"></a>元素访问</h3><p>由于栈本身的限制，所以只能通过top()来访问栈顶元素</p><h3 id="常见函数"><a href="#常见函数" class="headerlink" title="常见函数"></a>常见函数</h3><p>push(x):入栈</p><p>top():获得栈顶元素</p><p>pop():弹出栈顶元素</p><p>empty():空则返回true</p><p>size():元素个数</p><h3 id="常见用途-5"><a href="#常见用途-5" class="headerlink" title="常见用途"></a>常见用途</h3><p>模拟实现一些递归，防止程序对栈内存的限制导致程序运行出错</p><h2 id="pair"><a href="#pair" class="headerlink" title="pair"></a>pair</h2><h3 id="pair的构建"><a href="#pair的构建" class="headerlink" title="pair的构建"></a>pair的构建</h3><pre class=" language-lang-c"><code class="language-lang-c">//1pair<string, int> p;p.first = "hh";p.second = 5;//2p = make_pair("hh", 5);//3p = pair<string, int>("hh", 5);</code></pre><h3 id="常用函数-6"><a href="#常用函数-6" class="headerlink" title="常用函数"></a>常用函数</h3><p>比较操作数时，先以first的大小作为标准，只有当first相等时才去判别second</p><h3 id="常见用途-6"><a href="#常见用途-6" class="headerlink" title="常见用途"></a>常见用途</h3><p>1、用来代替二元结构体及其构造函数<br>2、作为map的键值对来进行插入</p><pre class=" language-lang-c"><code class="language-lang-c">map<string, int> mp;mp.insert(make_pair("hh", 5));mp.insert(pair<string, int>("hh", 5));</code></pre><h2 id="algorithm头文件下的常用函数"><a href="#algorithm头文件下的常用函数" class="headerlink" title="algorithm头文件下的常用函数"></a>algorithm头文件下的常用函数</h2><h3 id="max-min-abs-swap"><a href="#max-min-abs-swap" class="headerlink" title="max,min,abs,swap"></a>max,min,abs,swap</h3><p>max(x, y):返回x，y中的最大值</p><p>min(x, y):返回x，y中的最小值</p><p>abs(x):返回x的绝对值(x为整型)，浮点型用fabs</p><p>swap(x, y):交换x，y值</p><h3 id="reverse"><a href="#reverse" class="headerlink" title="reverse"></a>reverse</h3><p>reverse(it, it2): [it, it2)之间的元素反转</p><pre class=" language-lang-c"><code class="language-lang-c">int a[10] = {0, 1, 2 ,3, 4, 5};reverse(a, a + 4);  //变成3 2 1 0 4 5string str = "abcdefghi";reverse(str.begin() + 2, str.begin() + 6);//变成ab fedc ghi</code></pre><h3 id="next-permutation"><a href="#next-permutation" class="headerlink" title="next_permutation"></a>next_permutation</h3><p>给出一个序列在全排列中的下一个序列，到达最后一个会返回false</p><pre class=" language-lang-c"><code class="language-lang-c">int a[10] = {1, 2, 3};do {    printf("%d %d %d", a[0], a[1], a[2]);}while(next_permutation(a, a + 3)); //输出123 132 213 231 312 321</code></pre><h3 id="fill"><a href="#fill" class="headerlink" title="fill"></a>fill</h3><p>fill():数组或容器某一段区间内赋为某个相同的值，和memset不同，可为范围内任意值<br><code>fill(a, a + 5, 11); //将a[0] ~ a[4]赋值为11</code></p><h3 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h3><p>sort()：<br>sort(首元素地址(必填)，尾元素地址的下一个地址(必填)，比较函数(非必填);，默认递增</p><pre class=" language-lang-c"><code class="language-lang-c">//从大到小排序bool cmp(int a, int b) {    return a > b;}sort(a, a + 4, cmp);//结构体排序struct node {    int x, y;}ssd[10];bool cmp(node a, node b) {    if (a.x != b.x) return a.x > b.x;    return a.y < b.y;   //x递增，x相等情况下，y递减}sort(ssd, ssd + 3, cmp);//容器排序//基本类似，只有vector、string、deque可以使用sort//set、map用红黑树实现本身有序，故不允许使用sort</code></pre><h3 id="lower-bound、upper-bound"><a href="#lower-bound、upper-bound" class="headerlink" title="lower_bound、upper_bound"></a>lower_bound、upper_bound</h3><p>lower_bound(first, last, val)用来寻找在数组或容器的[first, last)范围内第一个大于等于val的元素的位置，数组则返回该位置的指针，容器则返回该位置的迭代器</p><p>upper_bound(first, last, val) 返回第一个大于val的元素的位置，其它同上</p><p>若数组或容器中没有需要寻找的元素，则返回可以插入该元素的位置的指针或迭代器</p><pre class=" language-lang-c"><code class="language-lang-c">int a[10] = {1, 2, 2, 3, 3, 3, 5, 5, 5, 5};//寻找-1int* lowerPos = lower_bound(a, a + 10, -1);int* upperPos = upper_bound(a, a + 10, -1);printf("%d %d\n", lowerPos - a, upperPos - a);//输出0, 0//要获得待查元素的下标，令返回值减去数组首地址//寻找1lowerPos = lower_bound(a, a + 10, 1);upperPos = upper_bound(a, a + 10, 1);printf("%d %d\n", lowerPos - a, upperPos - a);//输出0, 1 //寻找3lowerPos = lower_bound(a, a + 10, 3);upperPos = upper_bound(a, a + 10, 3);printf("%d %d\n", lowerPos - a, upperPos - a);//输出3, 6//寻找6lowerPos = lower_bound(a, a + 10, 6);upperPos = upper_bound(a, a + 10, 6);printf("%d %d\n", lowerPos - a, upperPos - a);//输出10, 10</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NG_ML02</title>
      <link href="/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%90%B4%E6%81%A9%E8%BE%BE%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/NG-ML02/"/>
      <url>/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%90%B4%E6%81%A9%E8%BE%BE%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/NG-ML02/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>吴恩达机器学习笔记--第一周</title>
      <link href="/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%90%B4%E6%81%A9%E8%BE%BE%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/NG-ML01/"/>
      <url>/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%90%B4%E6%81%A9%E8%BE%BE%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/NG-ML01/</url>
      
        <content type="html"><![CDATA[<h1 id="1-引言"><a href="#1-引言" class="headerlink" title="1 引言"></a>1 引言</h1><h2 id="欢迎（Welcome）"><a href="#欢迎（Welcome）" class="headerlink" title="欢迎（Welcome）"></a>欢迎（Welcome）</h2><p>blahblah，机器学习很厉害，你们快来学</p><h2 id="什么是机器学习（What-is-Machine-Learning）"><a href="#什么是机器学习（What-is-Machine-Learning）" class="headerlink" title="什么是机器学习（What is Machine Learning）"></a>什么是机器学习（What is Machine Learning）</h2><p>Arthur Samuel“在进行特定编程的情况下，给予计算机 学习能力的领域”</p><p>Tom Mitchell“一个好的学习问题定义如下，一个程序被认为能从经验 E 中学习，解决任务 T，达到性能度量值 P，当且仅当，有了经验 E 后，经过 P 评判，程序在处理 T 时的性能有所提升。我认为经验 E 就是程序上万次的自我练习的经验而任务 T 就是下棋。性能度量值 P 呢，就是它在与一 些新的对手比赛时，赢得比赛的概率”</p><h2 id="监督学习（Supervised-Learning）"><a href="#监督学习（Supervised-Learning）" class="headerlink" title="监督学习（Supervised  Learning）"></a>监督学习（Supervised  Learning）</h2><p>监督学习即给学习算法一个数据集。这个数据集由“正确答案”组成，再根据这些样本做出预测。在房价的例子中，我们给了一系列房子的数据，我们给定数据集中每个样本的正确价格， 即它们实际的售价然后运用学习算法，算出更多的正确答案</p><p><img src="http://pknivt4fw.bkt.clouddn.com/%E5%9B%BE%E7%89%871.png" alt="housingPricePre"></p><p>监督学习又叫回归问题（regression  problem）。我们通常试着推测一个连续值的结果，如房价。房价实际上是一系列离散的值，但我们将之看成实数、标量，所以又把它看成一个连续的值。回归即指：目标是预测一个连续的输出值 </p><p>分类问题（classification problem）：目标是预测离散值的输出，如肿瘤的良性/恶性<br><img src="http://pknivt4fw.bkt.clouddn.com/%E5%9B%BE%E7%89%872.png" alt="brestCancer"></p><p>支持向量机（Support Vector Machine）算法：由于在机器学习问题中通常有大量的特征，故需要有算法能让电脑处理无穷多的特征<br><img src="http://pknivt4fw.bkt.clouddn.com/%E5%9B%BE%E7%89%873.png" alt="classify"></p><h2 id="无监督学习（Unsupervised-Learning）、"><a href="#无监督学习（Unsupervised-Learning）、" class="headerlink" title="无监督学习（Unsupervised Learning）、"></a>无监督学习（Unsupervised Learning）、</h2><p>无监督学习的数据集中没有任何的标签、或有相同的标签，不知如何处理，也未告知每个数据点是什么。针对这样的数据集，无监督学习能判断出数据有n个不同的聚集簇。所以又叫做聚类算法（clustering algorithm）</p><p>可用于如基因分类、大数据中心（解决什么样的计算机易于协同工作）、社交网络分析（自动给出朋友分组，如常发邮件、Facebook好友etc）、市场分割（将顾客划分到不同的细分市场中，更有效的进行销售）、天文数据分析、鸡尾酒算法（分离两个音频）<br>鸡尾酒算法：[W,s,v] = svd((repmat(sum(x.<em>x,1),size(x,1),1).</em>x)*x’);</p><h1 id="2-单变量线性回归（Linear-Regression-with-One-Variable）"><a href="#2-单变量线性回归（Linear-Regression-with-One-Variable）" class="headerlink" title="2 单变量线性回归（Linear Regression with One Variable）"></a>2 单变量线性回归（Linear Regression with One Variable）</h1><h2 id="模型表示（Model-Representation）"><a href="#模型表示（Model-Representation）" class="headerlink" title="模型表示（Model Representation）"></a>模型表示（Model Representation）</h2><p><img src="http://pknivt4fw.bkt.clouddn.com/%E5%9B%BE%E7%89%875.png" alt=""></p><p>我们将要用来描述这个回归问题的标记如下:<br>m    训练集中实例的数量    特征/输入变量<br>xy    目标变量/输出变量<br>(x,y)    训练集中的实例<br>(<script type="math/tex">x^{(i)}</script>, <script type="math/tex">y^{(i)}</script>) 第i个观察实例<br>h    学习算法的解决方案或函数也称为假设（hypothesis）</p><p>监督学习工作方式如下：<br><img src="http://pknivt4fw.bkt.clouddn.com/%E5%9B%BE%E7%89%874.png" alt="工作方式"></p><p>h是一个x到y的映射，一种可能的表达：<script type="math/tex">h_{\Theta }=\Theta _{0} +\Theta _{1}x</script>，因为只含有一个特征/输入变量，所以叫做单变量线性回归问题</p><h2 id="代价函数（Cost-Function）"><a href="#代价函数（Cost-Function）" class="headerlink" title="代价函数（Cost Function）"></a>代价函数（Cost Function）</h2><p>需要选择合适的参数（parameters）和θ0、θ1，参数决定了得到的直线相对于训练集的准确程度。目标就在于选择出能使建模误差的平方和能够最小的模型参数，即代价函数 <script type="math/tex">J(\Theta _{0},\Theta _{1})=\frac{1}{2m}\sum_{i=1}^{m}(h_{\Theta }(x^{(\Theta )})-y^{(\Theta )})^{2}</script><br>p.s.均方误差之所以除以2，是由于带了平方，之后要用到梯度下降法，需要求导，这样可把2消掉，一个简化计算的技巧</p><p>绘制一个等高线，三个坐标分别为θ0、θ1、J（θ0，θ1），即在三维空间中存在一个使J（θ0，θ1）最小的点</p><p>代价函数（平方误差函数、平方误差代价函数），之所以求误差平方和，因为这可能是解决回归问题最常用的手段</p><h2 id="代价函数的直观理解Ⅰ（Cost-Function-IntuitionⅠ）"><a href="#代价函数的直观理解Ⅰ（Cost-Function-IntuitionⅠ）" class="headerlink" title="代价函数的直观理解Ⅰ（Cost Function - IntuitionⅠ）"></a>代价函数的直观理解Ⅰ（Cost Function - IntuitionⅠ）</h2><p><img src="http://pknivt4fw.bkt.clouddn.com/%E5%9B%BE%E7%89%877.png" alt=""></p><p><img src="http://pknivt4fw.bkt.clouddn.com/%E5%9B%BE%E7%89%878.png" alt=""></p><p><img src="http://pknivt4fw.bkt.clouddn.com/%E5%9B%BE%E7%89%879.png" alt=""></p><p><img src="http://pknivt4fw.bkt.clouddn.com/%E5%9B%BE%E7%89%8710.png" alt=""></p><h2 id="代价函数的直观理解Ⅱ（Cost-Function-IntuitionⅡ）"><a href="#代价函数的直观理解Ⅱ（Cost-Function-IntuitionⅡ）" class="headerlink" title="代价函数的直观理解Ⅱ（Cost Function - IntuitionⅡ）"></a>代价函数的直观理解Ⅱ（Cost Function - IntuitionⅡ）</h2><p>通过等高线图理解</p><p><img src="http://pknivt4fw.bkt.clouddn.com/%E5%9B%BE%E7%89%8711.png" alt=""></p><h2 id="梯度下降（Gradient-Descent）"><a href="#梯度下降（Gradient-Descent）" class="headerlink" title="梯度下降（Gradient Descent）"></a>梯度下降（Gradient Descent）</h2><p><img src="http://pknivt4fw.bkt.clouddn.com/%E5%9B%BE%E7%89%8712.png" alt=""></p><p>基本思想：开始时随机选择一个参数的组合（θ0,θ1,…..,θn），计算代价函数，寻找下一个能让代价函数值下降最多的参数组合，持续这么做知道得到一个局部最小值（local minimum）。由于并未尝试所有的参数组合，故不能确定是否为全局最小值（global minimum）</p><p><img src="http://pknivt4fw.bkt.clouddn.com/%E5%9B%BE%E7%89%8713.png" alt=""></p><p>批量梯度下降（batch gradient descent）算法公式：</p><p><img src="http://pknivt4fw.bkt.clouddn.com/%E5%9B%BE%E7%89%8714.png" alt=""><br>α为学习速率（learning rate），决定了沿着能让代价函数下降程度最大方向迈出的步子有多大。在批量梯度下降中，每次都要同时让所有的参数减去学习速率乘以代价函数的导数（注意需要同时更新θ0,θ1）</p><p><img src="http://pknivt4fw.bkt.clouddn.com/%E5%9B%BE%E7%89%8714.png" alt=""></p><h2 id="梯度下降的直观理解（Gradient-Descent-Intuition）"><a href="#梯度下降的直观理解（Gradient-Descent-Intuition）" class="headerlink" title="梯度下降的直观理解（Gradient Descent Intuition）"></a>梯度下降的直观理解（Gradient Descent Intuition）</h2><p>梯度下降算法：<script type="math/tex">\Theta _{j}=\Theta _{j}-\alpha \frac{\partial }{\partial \Theta _{j}}J(\Theta )</script><br>描述：对θ赋值，使得J(θ)按梯度下降最快的方向进行，不断迭代直至得到局部最小值</p><p><img src="http://pknivt4fw.bkt.clouddn.com/%E5%9B%BE%E7%89%8716.png" alt=""></p><p>若α过小，即学习速率太小，则速度过慢，需要很多步才能达到全局最小值<br>若α过大，那么梯度下降算法可能会越过最低点，导致无法收敛，甚至发散<br>随着梯度下降算法的运行，移动的幅度会自动变得越来越小，直到最终移动幅度非常小，导数趋于0，则已经收敛到局部最小值。所有实际上没必要再另外减小α</p><h2 id="梯度下降的线性回归（Gradient-Descent-For-Linear-Regression）"><a href="#梯度下降的线性回归（Gradient-Descent-For-Linear-Regression）" class="headerlink" title="梯度下降的线性回归（Gradient Descent For Linear Regression）"></a>梯度下降的线性回归（Gradient Descent For Linear Regression）</h2><p>将梯度下降和代价函数结合，应用于具体的拟合直线的线性回归算法中，梯度下降算法和线性回归算法比较如下：</p><p><img src="http://pknivt4fw.bkt.clouddn.com/%E5%9B%BE%E7%89%8717.png" alt=""></p><p>对线性回归问题运用梯度下降算法，即求出代价函数的导数：</p><p><img src="http://pknivt4fw.bkt.clouddn.com/%E5%9B%BE%E7%89%8718.png" alt=""></p><p>此算法又被称为批量梯度下降，指的是，在梯度下降的每一步中，都用到了所有的训练样本</p><h1 id="3-线性代数回顾（Linear-Algebra-Review）"><a href="#3-线性代数回顾（Linear-Algebra-Review）" class="headerlink" title="3 线性代数回顾（Linear Algebra Review）"></a>3 线性代数回顾（Linear Algebra Review）</h1><p>矩阵和向量（Matrices and Vectors）<br>加法和标量乘法（Addition and Scalar Multiplication）<br>矩阵向量乘法（Matrix Vector Multiplication）</p><p><img src="http://pknivt4fw.bkt.clouddn.com/%E5%9B%BE%E7%89%8719.png" alt=""></p><p>矩阵乘法（Matrix-matrix Multiplication）</p><p><img src="http://pknivt4fw.bkt.clouddn.com/%E5%9B%BE%E7%89%8720.png" alt=""></p><p>奇异/退化矩阵（singular / degenerate matrix）：逆矩阵不存在的矩阵<br>逆矩阵、转置矩阵（Inverse and Transpose Matrix）</p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>Hello World</title>
      <link href="/hello-world.html"/>
      <url>/hello-world.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="啊啊啊"><a href="#啊啊啊" class="headerlink" title="啊啊啊"></a>啊啊啊</h2><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-lang-bash"><code class="language-lang-bash">$ hexo new "My New Post"</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-lang-bash"><code class="language-lang-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-lang-bash"><code class="language-lang-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-lang-bash"><code class="language-lang-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>timeline</title>
      <link href="/timeline/index.html"/>
      <url>/timeline/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
